<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test Cilindro con Líneas BOH - GEOSTXR</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
        }
        
        #three-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        .controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            min-width: 300px;
        }
        
        .controls h3 {
            margin: 0 0 15px 0;
            color: #333;
            font-size: 18px;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #555;
        }
        
        .slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4CAF50;
            cursor: pointer;
        }
        
        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4CAF50;
            cursor: pointer;
            border: none;
        }
        
        .value-display {
            font-size: 14px;
            color: #666;
            margin-top: 5px;
        }
        
        .status {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <div id="three-container"></div>
    
    <div class="controls">
        <h3>Controles BOH</h3>
        
        <div class="control-group">
            <label>Línea BOH 1: <span id="line1-value">90.0°</span></label>
            <input type="range" class="slider" id="line1-slider" min="70" max="110" step="0.1" value="90">
        </div>
        
        <div class="control-group">
            <label>Línea BOH 2: <span id="line2-value">90.0°</span></label>
            <input type="range" class="slider" id="line2-slider" min="70" max="110" step="0.1" value="90">
        </div>
        
        <div class="control-group">
            <button onclick="resetAngles()" style="width: 100%; padding: 10px; background: #2196F3; color: white; border: none; border-radius: 5px; cursor: pointer;">
                Resetear a 90°
            </button>
        </div>
        
        <div class="value-display">
            <div>Diferencia: <span id="difference-value">0.0°</span></div>
        </div>
    </div>
    
    <div class="status">
        <div>GEOSTXR - Cilindro Virtual</div>
        <div>Dimensiones: 6.35cm × 30cm</div>
        <div>Líneas BOH en 90°</div>
    </div>

    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.169.0/build/three.module.js';
        
        // Variables globales
        let scene, camera, renderer, cylinderGroup, bohLine1, bohLine2;
        let container = document.getElementById('three-container');
        
        // Configuración del cilindro
        const CYLINDER_CONFIG = {
            DIAMETER: 6.35,
            HEIGHT: 30,
            RADIUS: 3.175,
            COLOR: 0x0066CC,
            OPACITY: 0.3
        };
        
        // Inicializar Three.js
        function initThreeJS() {
            // Scene
            scene = new THREE.Scene();
            
            // Camera - positioned at (0, 50, 15) looking at center of cylinder
            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(0, 50, 15);
            camera.lookAt(0, 0, 15);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setClearColor(0x000000, 0);
            container.appendChild(renderer.domElement);
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);
            
            // Create cylinder
            createCylinder();
            
            // Create BOH lines
            createBOHLines();
            
            // Animation loop
            animate();
        }
        
        // Create cylinder
        function createCylinder() {
            const radius = CYLINDER_CONFIG.RADIUS;
            const height = CYLINDER_CONFIG.HEIGHT;
            
            // Cylinder geometry
            const cylinderGeometry = new THREE.CylinderGeometry(radius, radius, height, 32);
            cylinderGeometry.rotateX(Math.PI / 2);
            
            // Cylinder material
            const cylinderMaterial = new THREE.MeshPhongMaterial({
                color: CYLINDER_CONFIG.COLOR,
                transparent: true,
                opacity: CYLINDER_CONFIG.OPACITY,
                side: THREE.DoubleSide,
                wireframe: false
            });
            
            // Create cylinder group
            cylinderGroup = new THREE.Group();
            cylinderGroup.position.set(0, 0, 15);
            cylinderGroup.scale.set(3, 3, 3);
            
            // Create cylinder mesh
            const cylinder = new THREE.Mesh(cylinderGeometry, cylinderMaterial);
            cylinder.position.set(0, 0, 0);
            cylinderGroup.add(cylinder);
            
            // Add borders
            addBorders(cylinderGroup);
            
            // Add the group to the scene
            scene.add(cylinderGroup);
        }
        
        // Add borders
        function addBorders(group) {
            const radius = CYLINDER_CONFIG.RADIUS;
            const height = CYLINDER_CONFIG.HEIGHT;
            
            const borderMaterial = new THREE.LineBasicMaterial({
                color: 0x000000,
                linewidth: 3
            });
            
            // Vertical line at 0° (front)
            const frontVerticalGeometry = new THREE.BufferGeometry();
            const frontVerticalPoints = [
                new THREE.Vector3(radius, 0, height / 2),
                new THREE.Vector3(radius, 0, -height / 2)
            ];
            frontVerticalGeometry.setFromPoints(frontVerticalPoints);
            const frontVertical = new THREE.Line(frontVerticalGeometry, borderMaterial);
            group.add(frontVertical);
            
            // Vertical line at 180° (back)
            const backVerticalGeometry = new THREE.BufferGeometry();
            const backVerticalPoints = [
                new THREE.Vector3(-radius, 0, height / 2),
                new THREE.Vector3(-radius, 0, -height / 2)
            ];
            backVerticalGeometry.setFromPoints(backVerticalPoints);
            const backVertical = new THREE.Line(backVerticalGeometry, borderMaterial);
            group.add(backVertical);
        }
        
        // Create BOH lines
        function createBOHLines() {
            const radius = CYLINDER_CONFIG.RADIUS;
            const height = CYLINDER_CONFIG.HEIGHT;
            
            // BOH Line material
            const bohMaterial = new THREE.LineBasicMaterial({
                color: 0xFF0000,
                linewidth: 3
            });
            
            // BOH Line 1: z=0 to z=15 (bottom to center) at 90°
            const line1Geometry = new THREE.BufferGeometry();
            const line1Points = [
                new THREE.Vector3(0, radius, 0),
                new THREE.Vector3(0, radius, height / 2)
            ];
            line1Geometry.setFromPoints(line1Points);
            bohLine1 = new THREE.Line(line1Geometry, bohMaterial);
            cylinderGroup.add(bohLine1); // Add to cylinder group so it scales with cylinder
            
            // BOH Line 2: z=15 to z=30 (center to top) at 90°
            const line2Geometry = new THREE.BufferGeometry();
            const line2Points = [
                new THREE.Vector3(0, radius, height / 2),
                new THREE.Vector3(0, radius, height)
            ];
            line2Geometry.setFromPoints(line2Points);
            bohLine2 = new THREE.Line(line2Geometry, bohMaterial);
            cylinderGroup.add(bohLine2); // Add to cylinder group so it scales with cylinder
        }
        
        // Update BOH lines
        function updateBOHLines(angle1, angle2) {
            if (!bohLine1 || !bohLine2) return;
            
            const radius = CYLINDER_CONFIG.RADIUS;
            const height = CYLINDER_CONFIG.HEIGHT;
            
            const angle1Rad = (angle1 * Math.PI) / 180;
            const angle2Rad = (angle2 * Math.PI) / 180;
            
            // Update Line 1
            const line1Points = [
                new THREE.Vector3(
                    Math.cos(angle1Rad) * radius,
                    Math.sin(angle1Rad) * radius,
                    0
                ),
                new THREE.Vector3(
                    Math.cos(angle1Rad) * radius,
                    Math.sin(angle1Rad) * radius,
                    height / 2
                )
            ];
            bohLine1.geometry.setFromPoints(line1Points);
            
            // Update Line 2
            const line2Points = [
                new THREE.Vector3(
                    Math.cos(angle2Rad) * radius,
                    Math.sin(angle2Rad) * radius,
                    height / 2
                ),
                new THREE.Vector3(
                    Math.cos(angle2Rad) * radius,
                    Math.sin(angle2Rad) * radius,
                    height
                )
            ];
            bohLine2.geometry.setFromPoints(line2Points);
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        
        // Event listeners
        document.getElementById('line1-slider').addEventListener('input', function(e) {
            const angle = parseFloat(e.target.value);
            document.getElementById('line1-value').textContent = angle.toFixed(1) + '°';
            updateBOHLines(angle, parseFloat(document.getElementById('line2-slider').value));
            updateDifference();
        });
        
        document.getElementById('line2-slider').addEventListener('input', function(e) {
            const angle = parseFloat(e.target.value);
            document.getElementById('line2-value').textContent = angle.toFixed(1) + '°';
            updateBOHLines(parseFloat(document.getElementById('line1-slider').value), angle);
            updateDifference();
        });
        
        function updateDifference() {
            const angle1 = parseFloat(document.getElementById('line1-slider').value);
            const angle2 = parseFloat(document.getElementById('line2-slider').value);
            const difference = Math.abs(angle2 - angle1);
            document.getElementById('difference-value').textContent = difference.toFixed(1) + '°';
        }
        
        function resetAngles() {
            document.getElementById('line1-slider').value = 90;
            document.getElementById('line2-slider').value = 90;
            document.getElementById('line1-value').textContent = '90.0°';
            document.getElementById('line2-value').textContent = '90.0°';
            updateBOHLines(90, 90);
            updateDifference();
        }
        
        // Handle window resize
        window.addEventListener('resize', function() {
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        });
        
        // Initialize
        initThreeJS();
    </script>
</body>
</html>
