<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test Direct Cylinder - GEOSTXR</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
        }
        
        #three-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        .status {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <div id="three-container"></div>
    
    <div class="status">
        <div>GEOSTXR - Test Direct Cylinder</div>
        <div>Camera: Y-axis view</div>
        <div>Cylinder: Z-axis aligned</div>
    </div>

    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.169.0/build/three.module.js';
        
        // Configuration
        const CYLINDER_CONFIG = {
            DIAMETER: 6.35,
            HEIGHT: 30,
            RADIUS: 3.175,
            COLOR: 0x0066CC,
            OPACITY: 0.3
        };
        
        let scene, camera, renderer;
        let container = document.getElementById('three-container');
        
        function initThreeJS() {
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            console.log('Initializing Three.js...', { width, height });
            
            // Scene
            scene = new THREE.Scene();
            
            // Camera - positioned to view cylinder from Y axis (lateral view)
            camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
            camera.position.set(0, 20, 0); // Closer to see full cylinder
            camera.lookAt(0, 0, 0); // Look at center
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            renderer.setSize(width, height);
            renderer.setClearColor(0x000000, 0);
            container.appendChild(renderer.domElement);
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);
            
            // Add coordinate axes for debugging - make them larger and more visible
            const axesHelper = new THREE.AxesHelper(15);
            scene.add(axesHelper);
            
            // Add individual axis lines for better visibility
            const xAxisGeometry = new THREE.BufferGeometry();
            const xAxisPoints = [
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(15, 0, 0)
            ];
            xAxisGeometry.setFromPoints(xAxisPoints);
            const xAxisMaterial = new THREE.LineBasicMaterial({ color: 0xff0000, linewidth: 3 });
            const xAxis = new THREE.Line(xAxisGeometry, xAxisMaterial);
            scene.add(xAxis);
            
            const yAxisGeometry = new THREE.BufferGeometry();
            const yAxisPoints = [
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(0, 15, 0)
            ];
            yAxisGeometry.setFromPoints(yAxisPoints);
            const yAxisMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00, linewidth: 3 });
            const yAxis = new THREE.Line(yAxisGeometry, yAxisMaterial);
            scene.add(yAxis);
            
            const zAxisGeometry = new THREE.BufferGeometry();
            const zAxisPoints = [
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(0, 0, 15)
            ];
            zAxisGeometry.setFromPoints(zAxisPoints);
            const zAxisMaterial = new THREE.LineBasicMaterial({ color: 0x0000ff, linewidth: 3 });
            const zAxis = new THREE.Line(zAxisGeometry, zAxisMaterial);
            scene.add(zAxis);
            
            // Axis labels will be added later - keeping it simple for now
            
            // Grid removed as requested
            
            // Create cylinder aligned with Z-axis
            const radius = CYLINDER_CONFIG.RADIUS;
            const cylinderHeight = CYLINDER_CONFIG.HEIGHT;
            
            // Create cylinder geometry - aligned with Z-axis
            const cylinderGeometry = new THREE.CylinderGeometry(radius, radius, cylinderHeight, 32);
            // No rotation needed - cylinder is already aligned with Y-axis by default
            // We want it aligned with Z-axis, so we rotate around X
            cylinderGeometry.rotateX(Math.PI / 2);
            
            const cylinderMaterial = new THREE.MeshPhongMaterial({
                color: CYLINDER_CONFIG.COLOR,
                transparent: true,
                opacity: CYLINDER_CONFIG.OPACITY,
                side: THREE.DoubleSide,
                wireframe: false
            });
            
            const cylinder = new THREE.Mesh(cylinderGeometry, cylinderMaterial);
            cylinder.position.set(0, 0, 0); // Centered
            cylinder.scale.set(3, 3, 3); // Scale to 3/4 of scene
            scene.add(cylinder);
            
            // Add borders
            const borderMaterial = new THREE.LineBasicMaterial({
                color: 0x000000,
                linewidth: 3
            });
            
            // Front border (0°)
            const frontGeometry = new THREE.BufferGeometry();
            const frontPoints = [
                new THREE.Vector3(radius * 2, 0, cylinderHeight * 2 / 2),
                new THREE.Vector3(radius * 2, 0, -cylinderHeight * 2 / 2)
            ];
            frontGeometry.setFromPoints(frontPoints);
            const frontLine = new THREE.Line(frontGeometry, borderMaterial);
            scene.add(frontLine);
            
            // Back border (180°)
            const backGeometry = new THREE.BufferGeometry();
            const backPoints = [
                new THREE.Vector3(-radius * 2, 0, cylinderHeight * 2 / 2),
                new THREE.Vector3(-radius * 2, 0, -cylinderHeight * 2 / 2)
            ];
            backGeometry.setFromPoints(backPoints);
            const backLine = new THREE.Line(backGeometry, borderMaterial);
            scene.add(backLine);
            
            // BOH Lines - positioned on cylinder surface
            const bohMaterial = new THREE.LineBasicMaterial({
                color: 0xFF0000,
                linewidth: 3
            });
            
            // BOH Line 1: z=0 to z=15 (bottom to center)
            const line1Geometry = new THREE.BufferGeometry();
            const line1Points = [
                new THREE.Vector3(0, radius * 2, -cylinderHeight * 2 / 2), // Bottom
                new THREE.Vector3(0, radius * 2, 0) // Center
            ];
            line1Geometry.setFromPoints(line1Points);
            const bohLine1 = new THREE.Line(line1Geometry, bohMaterial);
            scene.add(bohLine1);
            
            // BOH Line 2: z=15 to z=30 (center to top)
            const line2Geometry = new THREE.BufferGeometry();
            const line2Points = [
                new THREE.Vector3(0, radius * 2, 0), // Center
                new THREE.Vector3(0, radius * 2, cylinderHeight * 2 / 2) // Top
            ];
            line2Geometry.setFromPoints(line2Points);
            const bohLine2 = new THREE.Line(line2Geometry, bohMaterial);
            scene.add(bohLine2);
            
            console.log('Direct cylinder scene created successfully');
            
            // Animation loop
            function animate() {
                requestAnimationFrame(animate);
                renderer.render(scene, camera);
            }
            animate();
            
            // Handle window resize
            window.addEventListener('resize', function() {
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            });
        }
        
        initThreeJS();
    </script>
</body>
</html>
